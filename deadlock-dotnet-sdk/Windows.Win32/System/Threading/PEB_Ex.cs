/// This file supplements code generated by CsWin32
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;

namespace Windows.Win32.System.Threading;

/// <summary>
/// all data which must be copied via ReadProcessMemory
/// </summary>
internal class PEB_Ex
{
    public unsafe PEB_Ex(uint processId, PEB peb)
    {
        ProcessId = processId;
        ReadVmHandle = new(PInvoke.OpenProcess(PROCESS_ACCESS_RIGHTS.PROCESS_VM_READ, true, processId), true);
        Peb = peb;

        //{
        //    PEB_LDR_DATA* baseAddr = Peb.Ldr;
        //    PEB_LDR_DATA ldr = default;
        //    nuint br = default;
        //    if (PInvoke.ReadProcessMemory(ReadVmHandle, baseAddr, &ldr, (nuint)Marshal.SizeOf<PEB_LDR_DATA>(), &br))
        //        PebLdrData = ldr;
        //}

        {
            RTL_USER_PROCESS_PARAMETERS* baseAddr = Peb.ProcessParameters;
            RTL_USER_PROCESS_PARAMETERS procParams = default;
            nuint br = default;
            if (PInvoke.ReadProcessMemory(ReadVmHandle, baseAddr, &procParams, (nuint)Marshal.SizeOf<RTL_USER_PROCESS_PARAMETERS>(), &br))
            {
                ImagePathName = procParams.ImagePathName.ToStringLength();
                CommandLine = procParams.CommandLine.ToStringLength();
                //ProcessParameters = procParams;
            }
        }
    }

    public uint ProcessId { get; }
    public SafeProcessHandle? ReadVmHandle { get; }
    public PEB Peb { get; }

    //public PEB_LDR_DATA PebLdrData { get; } // unnecessary unless we want the process's module list
    public string? ImagePathName { get; }
    public string? CommandLine { get; }
    //public RTL_USER_PROCESS_PARAMETERS ProcessParameters { get; } // not needed unless hidden fields are implemented
}
