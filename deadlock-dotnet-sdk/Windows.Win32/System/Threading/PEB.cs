/// This file supplements code generated by CsWin32
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;
using Windows.Win32.Foundation;
using Win32Exception = System.ComponentModel.Win32Exception;

namespace Windows.Win32.System.Threading;

/// <summary>
/// all data which must be copied via ReadProcessMemory
/// </summary>
class PEB_Ex
{
    public PEB_Ex(uint processId, ref PEB peb)
    {
        ProcessId = processId;
        ReadVmHandle = new(PInvoke.OpenProcess(PROCESS_ACCESS_RIGHTS.PROCESS_VM_READ, true, processId), true);
        Peb = peb;

        unsafe
        {
            PEB_LDR_DATA* baseAddr = Peb.Ldr;
            PEB_LDR_DATA ldr = default;
            nuint br = default;
            if (PInvoke.ReadProcessMemory(ReadVmHandle, baseAddr, &ldr, (nuint)Marshal.SizeOf<PEB_LDR_DATA>(), &br))
                PebLdrData = ldr;
        }

        unsafe
        {
            RTL_USER_PROCESS_PARAMETERS* baseAddr = Peb.ProcessParameters;
            RTL_USER_PROCESS_PARAMETERS procParams = default;
            nuint br = default;
            if (PInvoke.ReadProcessMemory(ReadVmHandle, baseAddr, &procParams, (nuint)Marshal.SizeOf<RTL_USER_PROCESS_PARAMETERS>(), &br))
                ProcessParameters = procParams;
        }
    }

    public uint ProcessId { get; }
    public SafeProcessHandle? ReadVmHandle { get; }
    public PEB Peb { get; }

    public PEB_LDR_DATA PebLdrData { get; }
    public RTL_USER_PROCESS_PARAMETERS ProcessParameters { get; }
}

partial struct PEB
{
    public PEB(PROCESS_BASIC_INFORMATION pbi, out PEB_Ex pebEx)
    {
        this = pbi.Peb;
        pebEx = GetPebEx(pbi.ProcessId);
    }

    public PEB_Ex GetPebEx(uint processId) => new(processId, ref this);

    public bool InheritedAddressSpace => (BOOLEAN)Reserved1[0];
    public bool ReadImageFileExecOptions => (BOOLEAN)Reserved1[1];
    public bool BeingDebugged_bool => (BOOLEAN)BeingDebugged;

    #region bit field

    public bool ImageUsesLargePages => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.ImageUsesLargePages);
    public bool IsProtectedProcess => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.IsProtectedProcess);
    public bool IsImageDynamicallyRelocated => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.IsImageDynamicallyRelocated);
    public bool SkipPatchingUser32Forwarders => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.SkipPatchingUser32Forwarders);
    public bool IsPackagedProcess => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.IsPackagedProcess);
    public bool IsAppContainer => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.IsAppContainer);
    public bool IsProtectedProcessLight => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.IsProtectedProcessLight);
    public bool IsLongPathAwareProcess => ((R2_bits)Reserved2[0]).HasFlag(R2_bits.IsLongPathAwareProcess);

    [Flags]
    private enum R2_bits : byte
    {
        None = 0,
        ImageUsesLargePages,
        IsProtectedProcess,
        IsImageDynamicallyRelocated,
        SkipPatchingUser32Forwarders,
        IsPackagedProcess,
        IsAppContainer,
        IsProtectedProcessLight,
        IsLongPathAwareProcess
    }

    #endregion bit field

    public unsafe HANDLE Mutant => new((IntPtr)Reserved3._0);
    public unsafe IntPtr ImageBaseAddress => (IntPtr)Reserved3._1;

    /// <summary>
    /// Invoke ReadProcessMemory to copy the PED_LDR_DATA from the process's memory
    /// </summary>
    /// <param name="processId"></param>
    /// <exception cref="Win32Exception">ReadProcessMemory failed</exception>
    public unsafe PEB_LDR_DATA GetPebLdrData(uint processId)
    {
        using SafeProcessHandle hProcess = new(PInvoke.OpenProcess(PROCESS_ACCESS_RIGHTS.PROCESS_VM_READ, true, processId), true);
        PEB_LDR_DATA ldr = default;
        nuint bytesRead = default;

        if (PInvoke.ReadProcessMemory(hProcess, Ldr, &ldr, (nuint)Marshal.SizeOf<PEB_LDR_DATA>(), &bytesRead))
            return ldr;
        else throw new Win32Exception();
    }

    /// <summary>
    /// Invoke ReadProcessMemory to copy the RTL_USER_PROCESS_PARAMETERS from the process's memory
    /// </summary>
    /// <param name="processId"></param>
    /// <returns></returns>
    /// <exception cref="Win32Exception">ReadProcessMemory failed</exception>
    public unsafe RTL_USER_PROCESS_PARAMETERS GetProcessParameters(uint processId)
    {
        using SafeProcessHandle hProcess = new(PInvoke.OpenProcess(PROCESS_ACCESS_RIGHTS.PROCESS_VM_READ, true, processId), true);
        RTL_USER_PROCESS_PARAMETERS processParameters = default;
        nuint bytesRead = default;

        if (PInvoke.ReadProcessMemory(hProcess, ProcessParameters, &processParameters, (nuint)Marshal.SizeOf<RTL_USER_PROCESS_PARAMETERS>(), &bytesRead))
            return processParameters;
        else throw new Win32Exception();
    }

    public unsafe IntPtr SubSystemData => (IntPtr)Reserved4._0;
    public unsafe IntPtr ProcessHeap => (IntPtr)Reserved4._1;
    public unsafe IntPtr FastPebLock => (IntPtr)Reserved4._2;
    public unsafe IntPtr IFEOKey => (IntPtr)Reserved5;

    #region CrossProcessFlags

    public bool ProcessInJob => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessInJob);
    public bool ProcessInitializing => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessInitializing);
    public bool ProcessUsingVEH => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessUsingVEH);
    public bool ProcessUsingVCH => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessUsingVCH);
    public bool ProcessUsingFTH => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessUsingFTH);
    public bool ProcessPreviouslyThrottled => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessPreviouslyThrottled);
    public bool ProcessCurrentlyThrottled => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessCurrentlyThrottled);
    public bool ProcessImagesHotPatched => ((CrossProcessFlags)Reserved6).HasFlag(CrossProcessFlags.ProcessImagesHotPatched); // REDSTONE5 

    [Flags]
    private enum CrossProcessFlags : uint
    {
        None = 0,
        ProcessInJob = 0b0001,
        ProcessInitializing = 0b0010,
        ProcessUsingVEH = 0b0100,
        ProcessUsingVCH = 0b1000,
        ProcessUsingFTH = 0b1_0000,
        ProcessPreviouslyThrottled = 0b10_0000,
        ProcessCurrentlyThrottled = 0b100_0000,
        ProcessImagesHotPatched = 0b1000_0000
    }

    #endregion CrossProcessFlags

    public unsafe IntPtr KernelCallbackTable => (IntPtr)Reserved7;
    public unsafe IntPtr UserSharedInfoPtr => (IntPtr)Reserved7;
    public uint SystemReserved => Reserved8;

    //TODO: https://sourcegraph.com/github.com/winsiderss/systeminformer@master/-/blob/phnt/include/ntpebteb.h?L119
}
